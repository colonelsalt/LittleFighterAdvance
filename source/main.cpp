#include <tonc.h>

#include "maths.h"
#include "main.h"

#include "utility.h"

// This file is autogenerated from the file in the graphics folder
#include "freeze_0.h"

#include "forest_bg.h"


OBJ_ATTR g_ObjBuffer[128];
OBJ_AFFINE *g_AffineObjBuffer = (OBJ_AFFINE*)g_ObjBuffer;

static OBJ_ATTR* LoadSprite(void)
{
	// Load tiles and palette of sprite into video and palete RAM
	memcpy32(&tile_mem[4][0], freeze_0Tiles + 4 * 64 * 32, freeze_0TilesLen / 4);
	memcpy32(pal_obj_mem, freeze_0Pal, freeze_0PalLen / 4);

	oam_init(g_ObjBuffer, 128);

	OBJ_ATTR* Obj = &g_ObjBuffer[0];
	obj_set_attr(Obj,
	             ATTR0_SQUARE,  // Square, regular sprite
	             ATTR1_SIZE_64, // 64x64 pixels,
	             ATTR2_PALBANK(0) | 0); // palette index 0, tile index 0

	oam_copy(oam_mem, g_ObjBuffer, 1); // Update first OAM object

	return Obj;
}

static void LoadBackground(void)
{
	// Load palette
	memcpy32(pal_bg_mem, forest_bgPal, forest_bgPalLen / 4);
	// Load tiles into CBB 0
	memcpy32(&tile_mem[0][0], forest_bgTiles, forest_bgTilesLen / 4);
	// Load map into SBB 30
	memcpy32(&se_mem[30][0], forest_bgMap, forest_bgMapLen / 4);

	REG_BG0CNT = BG_CBB(0) | BG_SBB(30) | BG_4BPP | BG_REG_32x32;
}

static b32 g_CanDraw;
static entity Player;


void OnVBlank()
{
	if (g_CanDraw)
	{
		g_CanDraw = false;

		u32 CurrentFrame = Player.PlayingAnimation->Frames[Player.AnimationFrameIndex];
		memcpy32(&tile_mem[4][0], freeze_0Tiles + CurrentFrame * 64 * 32, PLAYER_FRAME_SIZE / 4);
		oam_copy(oam_mem, g_ObjBuffer, 1);
	}
}

static const bg_map ForestMap =
{ 
	500, 256,
	0, 0
};

static const animation PlayerIdle =
{
	.Frames = (u32[]){0, 1, 2, 3},
	.Length = 4,
	.FrameDelay = 9,
	.ShouldLoop = true
};

static const animation PlayerWalk =
{
	.Frames = (u32[]){4, 5, 6, 7},
	.Length = 4,
	.FrameDelay = 7,
	.ShouldLoop = true
};

static const animation PlayerRun =
{
	.Frames = (u32[]){20, 21, 22},
	.Length = 3,
	.FrameDelay = 5,
	.ShouldLoop = true
};

static const animation PlayerStartJump =
{
	.Frames = (u32[]){60, 61},
	.Length = 2,
	.FrameDelay = 6,
	.ShouldLoop = false

};

static const animation PlayerJumpLoop = 
{
	.Frames = (u32[]){62},
	.Length = 1,
	.FrameDelay = 1,
	.ShouldLoop = true
};

static const animation PlayerJumpFastLoop = 
{
	.Frames = (u32[]){63},
	.Length = 1,
	.FrameDelay = 1,
	.ShouldLoop = true
};

inline void SetAnimation(entity* Entity, const animation* Animation)
{
	if (Entity->PlayingAnimation != Animation)
	{
		Entity->PlayingAnimation = Animation;
		Entity->AnimationTimer = Animation->FrameDelay;
		Entity->AnimationFrameIndex = 0;
	}
}

inline b32 HasAnimationEnded(entity* Entity)
{
	const animation* Animation = Entity->PlayingAnimation;
	if (!Animation->ShouldLoop)
	{
		return Entity->AnimationFrameIndex >= Animation->Length - 1;
	}
	return false;
}


static void AnimateEntity(entity* Entity)
{
	const animation* Animation = Entity->PlayingAnimation;
	Entity->AnimationTimer--;
	if (Entity->AnimationTimer <= 0)
	{
		Entity->AnimationTimer = Animation->FrameDelay;
		if (Animation->ShouldLoop)
		{
			Entity->AnimationFrameIndex++;
			if (Entity->AnimationFrameIndex >= Animation->Length)
			{
				Entity->AnimationFrameIndex = 0;
			}
		}
		else
		{
			if (Entity->AnimationFrameIndex < Animation->Length - 1)
			{
				Entity->AnimationFrameIndex++;
			}
		}
	}
}

int main(void)
{
	irq_init(nullptr);
	irq_enable(II_VBLANK);
	irq_add(II_VBLANK, OnVBlank);

	Player.Sprite = LoadSprite();

	v2 PlayerStartPos = {};
	PlayerStartPos.X = 0;
	PlayerStartPos.Y = 90;
	
	Player.WorldPos = {};
	Player.WorldPos.X = Player.Width / 2;
	Player.WorldPos.Y = 0;

	SetAnimation(&Player, &PlayerIdle);

	Player.Width = 64;
	Player.Height = 64;

	LoadBackground();

	REG_DISPCNT = DCNT_MODE0 | DCNT_BG0 | DCNT_OBJ | DCNT_OBJ_1D;

	v2 CameraPos = {};

	while (true)
	{
		key_poll();

		if (Player.StartedJump)
		{
			Player.JumpTimer--;
			if (Player.JumpTimer <= 0)
			{
				Player.StartedJump = false;
				Player.VelocityZ = JUMP_SPEED;
				Player.IsAirborne = true;
			}
		}

		if (Player.IsAirborne)
		{
			Player.VelocityZ -= GRAVITY;
			Player.ZPos += Player.VelocityZ;
			if (Player.ZPos < 0)
			{
				Player.ZPos = 0;
				Player.IsAirborne = false;
			}
		}

		if (key_hit(KEY_LEFT))
		{
			SetHFlip(Player.Sprite, true);

			if (Player.LastInputX < 0 && Player.FramesSinceLastMovement <= DOUBLE_TAP_INTERVAL)
			{
				Player.IsRunning = true;
				Player.Velocity.X = -RUN_SPEED;
			}
			else
			{
				if (Player.Velocity.X >= RUN_SPEED)
				{
					Player.IsRunning = false;
					Player.Velocity.X = 0;
				}
			}
			Player.LastInputX = -1;
			Player.FramesSinceLastMovement = 0;
		}
		else if (key_hit(KEY_RIGHT))
		{
			SetHFlip(Player.Sprite, false);	

			if (Player.LastInputX > 0 && Player.FramesSinceLastMovement <= DOUBLE_TAP_INTERVAL)
			{
				Player.IsRunning = true;
				Player.Velocity.X = RUN_SPEED;
			}
			else
			{
				if (Player.Velocity.X <= -RUN_SPEED)
				{
					Player.IsRunning = false;
					Player.Velocity.X = 0;
				}
			}
			Player.LastInputX = 1;
			Player.FramesSinceLastMovement = 0;
		}
		else
		{
			Player.FramesSinceLastMovement++;
		}

		if (key_hit(KEY_A) && !Player.IsAirborne)
		{
			Player.StartedJump = true;
			Player.JumpTimer = JUMP_DELAY;
		}


		if (!Player.IsRunning)
		{
			Player.Velocity.X = WALK_SPEED * key_tri_horz();
		}
		Player.Velocity.Y = WALK_SPEED * key_tri_vert();


		if (!Player.StartedJump)
		{
			Player.WorldPos += Player.Velocity;
		}
		
		if (Player.WorldPos.X < 0)
		{
			Player.WorldPos.X = 0;
		}
		if (Player.WorldPos.X > ForestMap.Width)
		{
			Player.WorldPos.X = ForestMap.Width;
		}

		if (Player.WorldPos.Y > 104)
		{
			Player.WorldPos.Y = 104;
		}
		if (Player.WorldPos.Y < 0)
		{
 			Player.WorldPos.Y = 0;
		}

		v2 PlayerScreenPos = PlayerStartPos;
		
		v2 Cutoff = {};
		Cutoff.X = ForestMap.Width - SCREEN_WIDTH;
		Cutoff.Y = ForestMap.Height - SCREEN_HEIGHT;
		
		if (Player.WorldPos.X >= Cutoff.X)
		{
			// If there's less than a screen's width left of the map, move the player across the screen
			PlayerScreenPos.X += Player.WorldPos.X - Cutoff.X;
		}
		else
		{
			// Otherwise, just move the camera to follow the player
			CameraPos.X = Player.WorldPos.X - Player.Width / 2;
		}

		if (Player.WorldPos.Y >= Cutoff.Y)
		{
			PlayerScreenPos.Y += Player.WorldPos.Y - Cutoff.Y;
		}
		else
		{
			CameraPos.Y = Player.WorldPos.Y;
		}
		PlayerScreenPos.Y -= Player.ZPos;

		REG_BG0HOFS = CameraPos.X.WholePart;
		REG_BG0VOFS = CameraPos.Y.WholePart;

		if (Player.StartedJump)
		{
			SetAnimation(&Player, &PlayerStartJump);
		}
		else if (Player.IsAirborne)
		{
			if (Player.Velocity.X <= -RUN_SPEED)
			{
				SetAnimation(&Player, &PlayerJumpFastLoop);
			}
			else if (Player.Velocity.X >= RUN_SPEED)
			{
				SetAnimation(&Player, &PlayerJumpFastLoop);
			}
			else
			{
				SetAnimation(&Player, &PlayerJumpLoop);
			}
		}
		else
		{
			if (Player.IsRunning)
			{
				SetAnimation(&Player, &PlayerRun);
			}
			else if (SqMagnitude(Player.Velocity) > 0)
			{
				SetAnimation(&Player, &PlayerWalk);
			}
			else
			{
				SetAnimation(&Player, &PlayerIdle);
			}
		}


		AnimateEntity(&Player);
		SetObjPos(Player.Sprite, PlayerScreenPos);

		g_CanDraw = true;
		VBlankIntrWait();
	}
}
